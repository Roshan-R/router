---
title: Authorization in the Apollo Router
description: Strengthen your supergraph's security with advanced access controls
minVersion: 1.27.0
---

> ⚠️ **This is an [Enterprise feature](../enterprise-features/) of the Apollo Router.** It requires an organization with a [GraphOS Enterprise plan](https://www.apollographql.com/pricing/).
>
> If your organization _doesn't_ currently have an Enterprise plan, you can test out this functionality by signing up for a free [Enterprise trial](/graphos/org/plans/#enterprise-trials).

Whether your graph is small or large, you may need to restrict sensitive information to authenticated users or enforce conditional access rules. It's more efficient to do this on the supergraph level, rather than in your underlying services.
The Apollo Router lets you **control access to specific fields and types across your supergraph** through the `@authenticated` and `@requiresScopes` directives:

- The `@authenticated` directive works in a binary way: authenticated requests can access the specified field or type and unauthenticated requests can't.
- The `@requiresScopes` directive allows granular access control through scopes you define.

You define and use these directives on subgraph schemas, and GraphOS [composes](#composition-and-federation) them on to the supergraph schema.
The router then enforces these directives on all incoming requests.

## Prequisites

To use the router's authorization directives, you need to either configure [JWT authentication](./authn-jwt) or add a [router service coprocessor](../customizations/coprocessor) that adds **claims** to a request's context.
**Claims** are the individual details of a request's scope. They might include details like the ID of the associated user and/or any scopes assigned to that user.

If you configure [JWT authentication](./authn-jwt), the Apollo Router automatically adds a JWT token's claims to the request's context at the `apollo_authentication::JWT::claims` key.
To participate in the authorization process, the coprocessor you add needs to set the key `apollo_authentication::JWT::claims` in request contexts.

### JWT authentication configuration

To-do: Recipe for JWT auth with these directives

### Coprocessors for authorization

To-do: Coprocessors specifications

## Authorization directives

### `@authenticated`

The `@authenticated` directive marks specific fields and types as requiring authentication.
It works by checking for the`apollo_authentication::JWT::claims` key in a request's context.
If the request is authenticated, the router executes the query in its entirety.

For unauthenticated requests, the router removes `@authenticated` fields before planning the query.
The router filters out fields that require authentication and only executes the parts of the query that don't require it.
If every field in a particular subgraph's query is marked as requiring authentication, this can eliminate entire subgraph requests.

#### Prequisites

To use the `@authenticated` directive in a subgraph you can either:
- [import it from the `@link` directive](/federation/federated-types/federated-directives/#importing-directives) like so:

```graphql
extend schema
  @link(
    url: "https://specs.apollo.dev/federation/v2.5",
    import: [..., "@authenticated"])
```

- or define the directive like this:

```graphql
directive @authenticated on OBJECT | FIELD_DEFINITION | INTERFACE | SCALAR | ENUM
```

To-do: Enable them in some other way? Warn that turning them on can break things since previously unauthenticated requests will start returning errors.

#### Example `@authenticated` use case

Suppose you are building a social media platform and you only want authenticated users to be able to view other users' emails.
You also want to have a query called `me` that returns the authenticated user.

Your schema may look something like this:

```graphql
type Query {
  me: User @authenticated
  user(id: ID): User
}

type User {
  id: ID
  name: String
  email: String @authenticated
}
```

Consider the following query:

```graphql title="Sample query"
query {
  me {
    name
    email
  }
  user(id: "1234") {
    name
    email
  }
}
```

An authenticated request would execute the entire query.
For an unauthenticated request, the router would remove the `@authenticated` fields and execute the filtered query.

<CodeColumns>

```graphql title="Query executed for an authenticated request"
query {
  me {
    name
    email
  }
  user(id: "1234") {
    name
    email
  }
}
```

```graphql title="Query executed for an unauthenticated request"
query {
  user(id: "1234") {
    name
  }
}
```

</CodeColumns>

For an unauthenticated request, the router doesn't attempt to resolve the top-level `me` query, nor the email for the user with `id: "1234"`.
The response retains the initial request's shape but returns `null` for unauthorized fields and applies the [standard GraphQL null propagation rules](https://www.apollographql.com/blog/graphql/basics/using-nullability-in-graphql/#what-happens-if-you-try-to-return-null-for-a-non-null-field).

```json title="Unauthenticated request's response"
{
  "data": {
    "me": null,
    "user": {
        "name": "Ada",
        "email": null
    }
  },
  "errors": [
    {
      "message": "Unauthorized field or type",
      "path": [
        "me"
      ],
      "extensions": {
        "code": "UNAUTHORIZED_FIELD_OR_TYPE"
      }
    },
    {
      "message": "Unauthorized field or type",
      "path": [
        "user",
        "email"
      ],
      "extensions": {
        "code": "UNAUTHORIZED_FIELD_OR_TYPE"
      }
    }
  ]
}
```

If _every_ requested field requires authentication and a request is unauthenticated, the router generates an error indicating that the query is unauthorized.

### `@requiresScopes`

The `@requiresScopes` directive marks fields and types as restricted based on the scopes you require.
The directive should include a `scopes` argument that expects an array of required scopes.

The directive validates the required scopes by loading the object at the `apollo_authentication::JWT::claims` key in a request's context.
That object's `scope` key should contain a space separated list of scopes in the format defined by the [OAuth2 RFC for access token scopes](https://datatracker.ietf.org/doc/html/rfc6749#section-3.3).

Depending on the scopes present on the request, the router filters out unauthorized fields and types.
If a field's `scopes` array includes multiple scopes, the request must include _all_ required scopes to resolve it.
If every field on a particular subgraph query requires scopes that aren't present, this can eliminate entire subgraph requests.

#### Prequisites

To use the `@requiresScopes` directive in a subgraph you can either:
- [import it from the `@link` directive](/federation/federated-types/federated-directives/#importing-directives) like so:

```graphql
extend schema
  @link(
    url: "https://specs.apollo.dev/federation/v2.5",
    import: [..., "@requiresScopes"])
```

- or define the directive like this:

```graphql
directive @requiresScopes(scopes: [String!]!) on OBJECT | FIELD_DEFINITION | INTERFACE | SCALAR | ENUM
```



#### Example `@requiresScopes` use case

Imagine your social media platform has an ecommerce component.
You need to be able to query for the following:

- An authenticated user's profile (`me`)
- Other users' emails
- Products and the users who have ordered them

Your schema may look something like this:

```graphql title=""
type Query {
  me: User @requiresScopes(scopes: ["profile:read"])
  products: [Product!]
}

type User {
  id: ID
  name: String
  email: @requiresScopes(["user:read"])
  products: [Product!] @requiresScopes(["user:read", "inventory:read"])
}

type Product {
  id: ID
  name: String
  amount: Int @requiresScopes(["inventory:read"])
  orders: [User!] @requiresScopes(["user:read", "inventory:read"])
}
```

The router executes the following query differently, depending on the request's attached scopes.

If the request includes the `profile:read user:read` scope set, then the router would execute the following filtered query:

<CodeColumns>

```graphql title="Raw query to router"
query {
  me {
    name
    email
  }

  products {
    name
    amount
    orders {
      name
    }
  }
}
```

```graphql title="Scopes: 'profile:read user:read'"
query {
  me {
    name
    email
  }

  products {
    name
  }
}
```

</CodeColumns>

The response would include errors at the `/products/@/amount` and `/products/@/orders` paths.

If the request includes the `user:read inventory:read` scope set, then the router would execute the following filtered query: 

<CodeColumns>

```graphql title="Raw query to router"
query {
  me {
    name
    email
  }

  products {
    name
    amount
    orders {
      name
    }
  }
}
```

```graphql title="Scopes: 'user:read inventory:read'"
query {
  products {
    name
    amount
    orders {
      name
    }
  }
}
```

</CodeColumns>

The response would include an error at the `/me` path.

## Composition and federation

Authorization directives are defined at the subgraph level and the GraphOS composes them in the supergraph schema. In other words, if subgraph fields or types include either `@authenticated` or `@requiresScopes` directives, they are set on the supergraph too.

If multiple shared subgraph fields include `@requiresScopes`, the supergraph schema merges the sets of scopes required by each subgraph. For example, imagine one subgraph requires the `profile:read` scope on the `users` query:

```graphql title="Subgraph A"
type Query {
  users: [User!]! @requiresScopes(scopes: ["profile:read"])
}
```

And another subgraph requires the `user:read` scope on `users` query:

```graphql title="Subgraph B"
type Query {
  users: [User!]! @requiresScopes(scopes: ["user:read"])
}
```

Then the supergraph schema would require _both_ scopes for it.

```graphql title="Supergraph"
type Query {
  users: [User!]! @requiresScopes(scopes: ["profile:read", "user:read"])
}
```

### Authorization and `@key` fields

The [`@key` directive](https://www.apollographql.com/docs/federation/entities/) lets you create an entity whose fields resolve across multiple subgraphs.
If you use authorization directives on fields in [`@key` directives](https://www.apollographql.com/docs/federation/entities/), Apollo still joins those fields between the subgraphs, but the client cannot query them directly.

Consider these example subgraph schemas:

```graphql title="Product subgraph"
type Query {
  product: Product
}

type Product @key(fields: "id") {
  id: ID! @authenticated
  name: String!
  price: Int @authenticated
}
```

```graphql title="Inventory subgraph"
type Query {
  product: Product
}

type Product @key(fields: "id") {
  id: ID! @authenticated
  inStock: Boolean!
}
```

An unauthenticated request would successfully execute this query:

```graphql
query {
  product {
    name
    inStock
  }
}
```

Specifically, under the hood, the router would use the `id` field to resolve the `Product` entity, but it wouldn't return it.

For the following query, an unauthenticated request would resolve `null` for `id`. And since `id` is a non-nullable field, `product` would return `null`.

```graphql
query {
  product {
    id
    name
  }
}
```

This behavior is similar to what you can create with [contracts](/graphos/delivery/contracts/) and the [`@inaccessible` directive](https://www.apollographql.com/docs/federation/federated-types/federated-directives/#inaccessible).

### Authorization and interfaces

If a type [implementing an interface](https://www.apollographql.com/docs/apollo-server/schema/unions-interfaces/#interface-type) requires authorization, unauthorized requests can query the interface, but not any parts of the type that require authorization.

For example, consider this schema where the `User` interface doesn't require authentication, but the `Admin` type which implements `User` does:

```graphql
type Query {
  users: [User!]!
}

interface User {
  id: ID
  name: String
}

type Admin
implements User
@authenticated {
  id: ID
  name: String
  role: String 
}
```

If an unauthenticated request were to make this query:

```graphql
query {
  users {
    id
    name
    ... on Admin {
      role
    }
  }
}
```

The router would filter the query as follows:

```graphql
query {
  users {
    id
    name
  }
}
```

The response would include an `"UNAUTHORIZED_FIELD_OR_TYPE"` error at the `/users/@/role` path.

## Introspection

Authorization directives don't affect introspection; all fields that require authorization remain visible. However, directives applied to fields _aren't_ visible. If introspection might reveal too much information about internal types, then be sure to deactivate it:

```yaml
supergraph:
  introspection: false
```

You can also hide fields using [contracts](/graphos/delivery/contracts/).

## Query deduplication

When [query deduplication](/configuration/traffic-shaping/#query-deduplication) is activated for subgraphs, the authorization status is accounted for: the router groups unauthenticated queries together, and authenticated queries are grouped by scope set.