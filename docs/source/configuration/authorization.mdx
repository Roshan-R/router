---
title: Authorization in the Apollo Router
description: Strengthen your supergraph's security with advanced access controls
minVersion: 1.27.0
---
<GraphOSEnterpriseRequired />

<FeatureInPreview />

APIs provide access to business-critical data. Unrestricted access can result in data breaches, monetary losses, or potential denial of service. Even for internal APIs, checks can be essential to limit data to authorized parties.

Enforcing authorization before processing requests is efficient because it allows for early request termination. It also enhances security by creating an initial checkpoint that can be reinforced in other service layers.

The Apollo Router provides fine-grained access control at your graph's edge. Using the `@authenticated`, `@requiresScopes` and `@policy` directives, you can define access to specific fields and types across your supergraph:

- The `@authenticated` directive works in a binary way: authenticated requests can access the specified field or type and unauthenticated requests can't.
- The `@requiresScopes` directive allows granular access control through scopes you define.
- The `@policy` directive offloads authorization policy execution to a [Rhai script](../customizations/rhai/) or a [coprocessor](../customizations/coprocessor) and integrates the result in the router.

You define and use these directives on subgraph schemas, and GraphOS [composes](#composition-and-federation) them on to the supergraph schema.
The router then enforces these directives on all incoming requests.

## Prerequisites

To use the router's authorization directives, you need to either configure [JWT authentication](./authn-jwt) or add a [router service coprocessor](../customizations/coprocessor) that adds **claims** to a request's context.
Claims are the individual details of a request's authentication and scope. They might include details like the ID of the associated user and/or any scopes assigned to that user.

### JWT authentication configuration

If you configure [JWT authentication](./authn-jwt), the Apollo Router automatically adds a JWT token's claims to the request's context at the `apollo_authentication::JWT::claims` key.

To-do: More information on how to use JWT auth with these directives

### Claim augmentation via coprocessors

Tokens can come in with limited information, that is then used to look up user specific information like roles. This can be done with [coprocessors](/customizations/coprocessor).

The router level coprocessor is guaranteed to be called after the authentication plugin, so the coprocessor can receive the list of claims extracted from the token, use information like the `sub` (subject) claim to look up the user, insert its data in the claims list and return it to the router.

If the router is configured with:

```yaml title="router.yaml"
authentication:
  router:
    jwt:
      jwks:
        - url: "file:///etc/router/jwks.json"

coprocessor:
  url: http://127.0.0.1:8081
  router:
    request:
      context: true
```

The coprocessor can then receive a request with this format:

```json
{
    "version": 1,
    "stage": "RouterRequest",
    "control": "continue",
    "id": "d0a8245df0efe8aa38a80dba1147fb2e",
    "context": {
        "entries": {
            "apollo_authentication::JWT::claims": {
                "exp": 10000000000,
                "sub": "457f6bb6-789c-4e8b-8560-f3943a09e72a"
            }
        }
    },
    "method": "POST"
}
```

The coprocessor would then look up the user with identifier specified in the `sub` claim, and return a response with more claims:


```json
{
    // Control properties
    "version": 1,
    "stage": "RouterRequest",
    "control": "continue",
    "id": "d0a8245df0efe8aa38a80dba1147fb2e",
    "context": {
        "entries": {
            "apollo_authentication::JWT::claims": {
                "exp": 10000000000,
                "sub": "457f6bb6-789c-4e8b-8560-f3943a09e72a",
                "scope": "profile:read profile:write"
            }
        }
    }
}
```

## Authorization directives

### `@authenticated`

The `@authenticated` directive marks specific fields and types as requiring authentication.
It works by checking for the `apollo_authentication::JWT::claims` key in a request's context.
If the request is authenticated, the router executes the query in its entirety.

If the request is unauthenticated, the router removes `@authenticated` fields before planning the query and only executes the parts of the query that don't require authentication.
If every field in a particular subgraph's query is marked as requiring authentication, this can eliminate entire subgraph requests, thereby increasing router efficiency.

#### Usage

To use the `@authenticated` directive in a subgraph you can [import it from the `@link` directive](/federation/federated-types/federated-directives/#importing-directives) like so:

```graphql
extend schema
  @link(
    url: "https://specs.apollo.dev/federation/v2.5",
    import: [..., "@authenticated"])
```

#### Example `@authenticated` use case

Suppose you're building a social media platform. Unauthenticated users can view a public post's title, author, and content.
However, you only want authenticated users to be able to see the number of views a post has received.
You also need to be able to query for an authenticated user's information.

Your schema may look something like this:

```graphql
type Query {
  me: User @authenticated
  post(id: ID!): Post
}

type User {
  id: ID!
  username: String
  posts: [Post!]!
}

type Post {
  id: ID!
  author: User!
  title: String!
  content: String!
  views: Int @authenticated
}

```

Consider the following query:

```graphql title="Sample query"
query {
  me {
    username
  }
  post(id: "1234") {
    title
    views
  }
}
```

The router would executed the entire request if it's authenticated.
For an unauthenticated request, the router would remove the `@authenticated` fields and execute the filtered query.

<CodeColumns>

```graphql title="Query executed for an authenticated request"
query {
  me {
    username
  }
  post(id: "1234") {
    title
    views
  }
}
```

```graphql title="Query executed for an unauthenticated request"
query {
  post(id: "1234") {
    title
  }
}
```

</CodeColumns>

For an unauthenticated request, the router doesn't attempt to resolve the top-level `me` query, nor the views for the post with `id: "1234"`.
The response retains the initial request's shape but returns `null` for unauthorized fields and applies the [standard GraphQL null propagation rules](https://www.apollographql.com/blog/graphql/basics/using-nullability-in-graphql/#what-happens-if-you-try-to-return-null-for-a-non-null-field).

```json title="Unauthenticated request's response"
{
  "data": {
    "me": null,
		"post": {
			"title": "Securing supergraphs",
		}
  },
  "errors": [
    {
      "message": "Unauthorized field or type",
      "path": [
        "me"
      ],
      "extensions": {
        "code": "UNAUTHORIZED_FIELD_OR_TYPE"
      }
    },
    {
      "message": "Unauthorized field or type",
      "path": [
        "post",
        "views"
      ],
      "extensions": {
        "code": "UNAUTHORIZED_FIELD_OR_TYPE"
      }
    }
  ]
}
```

If _every_ requested field requires authentication and a request is unauthenticated, the router generates an error indicating that the query is unauthorized.

### `@requiresScopes`

The `@requiresScopes` directive marks fields and types as restricted based on required scopes.
Depending on the scopes present on the request, the router filters out unauthorized fields and types.
The directive should include a `scopes` argument that defines an array of the required scopes.

```graphql
@requiresScopes(scopes: ["scope1", "scope2", "scope3"])
```

> If a field's required `scopes` array includes multiple scopes, the request must include _all_ required scopes to resolve it.

The directive validates the required scopes by loading the claims object at the `apollo_authentication::JWT::claims` key in a request's context.
The claims object's `scope` key's value should be a space separated string of scopes in the format defined by the [OAuth2 RFC for access token scopes](https://datatracker.ietf.org/doc/html/rfc6749#section-3.3).

```rhai
claims = context["apollo_authentication::JWT::claims"]
claims["scope"] = "scope1 scope2 scope3"
```

<ExpansionPanel title="What if my scopes aren't in this format?">

If the `apollo_authentication::JWT::claims` token holds scopes in another format, for example, an array of strings, or in another claim, you can edit the claims with a [custom Rhai script](../customizations/rhai).

The example below extracts an array of scopes from the `roles` claim and reformats them as a space separated string.

```Rhai
fn router_service(service) {
  let request_callback = |request| {
    let claims = request.context["apollo_authentication::JWT::claims"];
    let roles = claims["roles"];

    let scope = "";
    if roles.len() > 1 {
      scope = roles[0];
    }

    if roles.len() > 2 {
      for role in roles[1..] {
        scope += ' ';
        scope += role;
      }
    }

    claims["scope"] = scope;
    request.context["apollo_authentication::JWT::claims"] = claims;
  };
  service.map_request(request_callback);
}
```

</ExpansionPanel>

Like the efficiencies gained via the `@authenticated` directive, if every field on a particular subgraph query requires scopes that aren't present, this can eliminate entire subgraph requests.

#### Usage

To use the `@requiresScopes` directive in a subgraph you can [import it from the `@link` directive](/federation/federated-types/federated-directives/#importing-directives) like so:

```graphql
extend schema
  @link(
    url: "https://specs.apollo.dev/federation/v2.5",
    import: [..., "@requiresScopes"])
```

#### Example `@requiresScopes` use case

Imagine the social media platform you're building lets users view other users' information only if they have the required permissions.
Your schema may look something like this:

```graphql title=""
type Query {
  me: User @authenticated
  user(id: ID!): User @requiresScopes(scopes: ["read:others"])
  users: [User!]! @requiresScopes(scopes: ["read:others"])
  post(id: ID!): Post
}

type User {
  id: ID!
  username: String
  email: String @requiresScopes(scopes: ["read:email"])
  profileImage: String
  posts: [Post!]!
}

type Post {
  id: ID!
  author: User!
  title: String!
  content: String!
  views: Int @authenticated
}
```

The router executes the following query differently, depending on the request's attached scopes.

If the request includes only the `read:others` scope, then the router would execute the following filtered query:

<CodeColumns>

```graphql title="Raw query to router"
query {
  users {
    username
    profileImage
    email
  }
}
```

```graphql title="Scopes: 'read:others'"
query {
  users {
    username
    profileImage
  }
}
```

</CodeColumns>

The response would include an errors at the `/users/@/email` path since that field requires the `read:emails` scope.

If the request includes the `read:others read:emails` scope set, then the router can successfully execute the entire query.

### `@policy`

The `@policy` directive marks fields and types as restricted based on authorization policies evaluated in a [Rhai script](../customizations/rhai/) or[coprocessor](../customizations/coprocessor).
The directive should include a `policies` argument that defines an array of the required policies. The example below includes one policy that requires all roles from the claims object to include the string `"support"`.

```graphql
@policy(policies: ["claims[`roles`].contains(`support`)"])
```

The Apollo Router extracts the list of policies relevant to a request from the schema. It then stores them in the request's context, under the key `apollo_authorization::policies::required` as a map `policy -> null|true|false`. This happens at the [Router service level](../customizations/overview#the-request-lifecycle). A Rhai script or a coprocessor at the Supergraph service level goes through this map, setting the value to `true` if they are successful and `false` if not. After that, the router filters the requests' types and fields to only those where the policy is `true`.
If the `policies` array contains multiple elements, only one of them has to be successful for the policy to be `true`.

Like the efficiencies gained via the authorization directives, if every field on a particular subgraph query is unauthorized because none of its policies pass, this can eliminate entire subgraph requests.

#### Usage

To use the `@policy` directive in a subgraph you can [import it from the `@link` directive](/federation/federated-types/federated-directives/#importing-directives) like so:

```graphql
extend schema
  @link(
    url: "https://specs.apollo.dev/federation/v2.5",
    import: [..., "@policy"])
```

Using the `@policy` directive requires a [Supergraph plugin](../customizations/overview) to evaluate the authorization policies. You can do this with a a [Rhai script](../customizations/rhai/), [coprocessor](../customizations/coprocessor), or [native plugin](/customizations/native). Refer to the following Rhai script and coprocessor examples for more information.

##### Usage with a Rhai script

<ExpansionPanel title="Click to expand">

The `policies` argument contains a list of strings, with no formatting constraints, so you can use them to store Rhai code. As an example,the following schema defines policies as boolean expressions that will be evaluated in Rhai:

```graphql
type Query {
  me: User @join__field(graph: ACCOUNTS) @policy(policies: ["claims[`kind`] == `user`"])
}

type User
  @join__owner(graph: ACCOUNTS)
  @join__type(graph: ACCOUNTS, key: "id") {
  id: ID! @join__field(graph: ACCOUNTS)
  username: String @join__field(graph: ACCOUNTS)
  username: String @join__field(graph: ACCOUNTS) @policy(policies: ["claims[`roles`].contains(`support`)"])
}
```

You can then use the following Rhai script to evaluate the policies:

```
fn supergraph_service(service) {
  let request_callback = |request| {
    let claims = request.context["apollo_authentication::JWT::claims"];

    let policies = request.context["apollo_authorization::policies::required"];

    for key in policies.keys() {
      let result = eval(key);
      policies[key] = result;
    }

    request.context["apollo_authorization::policies::required"] = policies;
  };
  service.map_request(request_callback);
}
```

The script uses the [`eval` function](https://rhai.rs/book/ref/eval.html) to evaluate each policy and store the result in the `apollo_authorization::policies::required` map.

</ExpansionPanel>

##### Usage with a coprocessor

You can use a [coprocessor](../customizations/coprocessor) called at the Supergraph request stage to receive the list of policies and execute them. This is useful to bridge the router authorization with an existing authorization stack, or link policy execution with lookups in a database.

<ExpansionPanel title="Click to expand">

Suppose you only want a user with a `read_profile` policy to have access to their own information. An additional policy `read_credit_card` is required to access credit card information. Your schema may look something like this:

```graphql
type Query {
  me: User @join__field(graph: ACCOUNTS) @policy(policies: ["read_profile"])
}

type User
  @join__owner(graph: ACCOUNTS)
  @join__type(graph: ACCOUNTS, key: "id") {
  id: ID! @join__field(graph: ACCOUNTS)
  username: String @join__field(graph: ACCOUNTS)
  credit_card: String @join__field(graph: ACCOUNTS) @policy(policies: ["read_credit_card"])
}
```

If you configure your router like this:

```yaml title="router.yaml"
coprocessor:
  url: http://127.0.0.1:8081
  supergraph:
    request:
      context: true
```

then a coprocessor can then receive a request with this format:

```json
{
    "version": 1,
    "stage": "SupergraphRequest",
    "control": "continue",
    "id": "d0a8245df0efe8aa38a80dba1147fb2e",
    "context": {
        "entries": {
            "apollo_authentication::JWT::claims": {
                "exp": 10000000000,
                "sub": "457f6bb6-789c-4e8b-8560-f3943a09e72a"
            },
            "apollo_authorization::policies::required": {
                "read_profile": null,
                "read_address": null
            }
        }
    },
    "method": "POST"
}
```

A user can read their own profile, so `read_profile` will succeed. But only the billing system should be able to see the credit card, so `read_credit_card` will fail. The corpocessor will then return:


```json
{
    // Control properties
    "version": 1,
    "stage": "SupergraphRequest",
    "control": "continue",
    "id": "d0a8245df0efe8aa38a80dba1147fb2e",
    "context": {
        "entries": {
            "apollo_authentication::JWT::claims": {
                "exp": 10000000000,
                "sub": "457f6bb6-789c-4e8b-8560-f3943a09e72a"
            },
            "apollo_authorization::policies::required": {
                "read_profile": true,
                "read_address": false
            }
        }
    }
}
```

</ExpansionPanel>

## Composition and federation

Authorization directives are defined at the subgraph level and the GraphOS composes them in the supergraph schema. In other words, if subgraph fields or types include `@authenticated`, `@requiresScopes`, or `@policy` directives, they are set on the supergraph too.

If multiple shared subgraph fields include `@requiresScopes`, the supergraph schema merges the sets of scopes required by each subgraph. For example, imagine one subgraph requires the `read:others` scope on the `users` query:

```graphql title="Subgraph A"
type Query {
  users: [User!]! @requiresScopes(scopes: ["read:others"])
}
```

And another subgraph requires the `read:profiles` scope on `users` query:

```graphql title="Subgraph B"
type Query {
  users: [User!]! @requiresScopes(scopes: ["read:profiles"])
}
```

Then the supergraph schema would require _both_ scopes for it.

```graphql title="Supergraph"
type Query {
  users: [User!]! @requiresScopes(scopes: ["read:others", "read:profiles"])
}
```

### Authorization and `@key` fields

The [`@key` directive](https://www.apollographql.com/docs/federation/entities/) lets you create an entity whose fields resolve across multiple subgraphs.
If you use authorization directives on fields defined in [`@key` directives](https://www.apollographql.com/docs/federation/entities/), Apollo still uses those fields to compose entities between the subgraphs, but the client cannot query them directly.

Consider these example subgraph schemas:

```graphql title="Product subgraph"
type Query {
  product: Product
}

type Product @key(fields: "id") {
  id: ID! @authenticated
  username: String!
  price: Int @authenticated
}
```

```graphql title="Inventory subgraph"
type Query {
  product: Product
}

type Product @key(fields: "id") {
  id: ID! @authenticated
  inStock: Boolean!
}
```

An unauthenticated request would successfully execute this query:

```graphql
query {
  product {
    username
    inStock
  }
}
```

Specifically, under the hood, the router would use the `id` field to resolve the `Product` entity, but it wouldn't return it.

For the following query, an unauthenticated request would resolve `null` for `id`. And since `id` is a non-nullable field, `product` would return `null`.

```graphql
query {
  product {
    id
    username
  }
}
```

This behavior is similar to what you can create with [contracts](/graphos/delivery/contracts/) and the [`@inaccessible` directive](https://www.apollographql.com/docs/federation/federated-types/federated-directives/#inaccessible).

### Authorization and interfaces

If a type [implementing an interface](https://www.apollographql.com/docs/apollo-server/schema/unions-interfaces/#interface-type) requires authorization, unauthorized requests can query the interface, but not any parts of the type that require authorization.

For example, consider this schema where the `Post` interface doesn't require authentication, but the `PrivateBlog` type which implements `Post` does:

```graphql
type Query {
  posts: [Post!]!
}

type User {
  id: ID!
  username: String
  posts: [Post!]!
}

interface Post {
  id: ID!
  author: User!
  title: String!
  content: String!
}

type PrivateBlog implements Post @authenticated {
  id: ID!
  author: User!
  title: String!
  content: String!
  publishAt: String
  allowedViewers: [User!]!
}
```

If an unauthenticated request were to make this query:

```graphql
query {
  posts {
    id
    author
    title
    ... on PrivateBlog {
      allowedViewers
    }
  }
}
```

The router would filter the query as follows:

```graphql
query {
  posts {
    id
    author
    title
  }
}
```

The response would include an `"UNAUTHORIZED_FIELD_OR_TYPE"` error at the `/posts/@/allowedViewers` path.

## Introspection

Authorization directives don't affect introspection; all fields that require authorization remain visible. However, directives applied to fields _aren't_ visible. If introspection might reveal too much information about internal types, then be sure to deactivate it:

```yaml
supergraph:
  introspection: false
```

You can also hide fields using [contracts](/graphos/delivery/contracts/).

## Query deduplication

When [query deduplication](/configuration/traffic-shaping/#query-deduplication) is activated for subgraphs, the authorization status is accounted for: the router groups unauthenticated queries together, and authenticated queries are grouped by scope set.