---
title: Authorization in the Apollo Router
---

> ⚠️ **This is an [Enterprise feature](../enterprise-features/) of the Apollo Router.** It requires an organization with a [GraphOS Enterprise plan](https://www.apollographql.com/pricing/).
>
> If your organization _doesn't_ currently have an Enterprise plan, you can test out this functionality by signing up for a free [Enterprise trial](/graphos/org/plans/#enterprise-trials).

You may need to restrict sensitive information to authorized users or roles or enforce conditional access rules for particular fields.
The Apollo Router allows you to restrict access to specific fields and types through the `@authenticated` and `@requiresScopes` directives:

- The `@authenticated` directive works in a binary way: requests are either authorized to access a specific field or type or they aren't.
- The `@requiresScopes` directive allows you granular access control through scopes that you define.

You define and use the directives on a sub-graph level, and the router [composes](#composition) them to the supergraph level.

## Prequisites

To use the router's authorization directives, you need to either configure [JWT authentication](./authn-jwt) or add a [router service coprocessor](../customizations/coprocessor). The JWT plugin validates the token, extract its claims, and sets them in the request context at the key `apollo_authentication::JWT::claims`.
To participate in the authorization process, a coprocessor needs to set the key `apollo_authentication::JWT::claims` in requests' context.

## Authorization directives

### `@authenticated`

The `@authenticated` directive marks specific fields and types as requiring authentication.
It works by checking for the`apollo_authentication::JWT::claims` key in a request's context.
If the request is authenticated, the router executes the query in its entirety.

For unauthenticated requests, the router removes `@authenticated` fields before planning the query.
The router filters out fields that require authentication and only executes the parts of the query that don't require it.
If every field in a particular subgraph's query is marked as requiring authentication, this can eliminate entire subgraph requests.

Define the `@authenticated` directive on any subgraph schema you want to use it on.

```graphql
directive @authenticated on OBJECT | FIELD_DEFINITION | INTERFACE | SCALAR | ENUM
```

#### Example `@authenticated` use case

Suppose you are building a social media platform and you only want authenticated users to be able to view other users' emails.
You also want to have a query called `me` that returns the authenticated user.

Your schema may look something like this:

```graphql
type Query {
  me: User @authenticated
  user(id: ID): User
}

type User {
  id: ID
  name: String
  email: String @authenticated
}
```

Consider the following query:

```graphql
query {
  me {
    name
    email
  }
  user(id: "1234") {
    name
    email
  }
}
```

An authenticated request would execute the entire query.
For an unauthenticated request, the router would remove the `@authenticated` fields before execution, and create a filtered query.

<CodeColumns>

```graphql title="Query for an authenticated request"
query {
  me {
    name
    email
  }
  user(id: "1234") {
    name
    email
  }
}
```

```graphql title="Filtered query for an unauthenticated request"
query {
  user(id: "1234") {
    name
  }
}
```
</CodeColumns>

For an unauthenticated request, the router doesn't attempt to resolve the top-level `me` query nor the email for the user with `id: "1234"`.
The response retains the initial request's shape but returns `null` for unauthorized fields and applies the [standard GraphQL null propagation rules](https://www.apollographql.com/blog/graphql/basics/using-nullability-in-graphql/#what-happens-if-you-try-to-return-null-for-a-non-null-field).



```json
{
  "data": {
    "me": null,
    "user": {
        "name": "Ada",
        "email": null
    }
  },
  "errors": [
    {
      "message": "Unauthorized field or type",
      "path": [
        "me"
      ],
      "extensions": {
        "code": "UNAUTHORIZED_FIELD_OR_TYPE"
      }
    },
    {
      "message": "Unauthorized field or type",
      "path": [
        "user",
        "email"
      ],
      "extensions": {
        "code": "UNAUTHORIZED_FIELD_OR_TYPE"
      }
    }
  ]
}
```

If every requested field requires authentication and a request is unauthenticated, the router generates a query planner error indicating that the query is unauthorized.

### `@requiresScopes`

```graphql
directive @requiresScopes(scopes: [String!]!) on OBJECT | FIELD_DEFINITION | INTERFACE | SCALAR | ENUM
```

The `@requiresScopes` directive restricts access to fields and types if the request did not present the right set of scopes, by loading from the request the context the object at key `apollo_authentication::JWT::claims`, and in that object the `scope` key, in the format defined by [OAuth2 access token scopes](https://datatracker.ietf.org/doc/html/rfc6749#section-3.3), as a space separated list of scopes.

Depending on which scope set is presented by the request, different parts of the query may be available.

Assuming we have this schema:

```graphql
type Query {
    me: User @requiresScopes(scopes: ["profile:read"])
    products: [Products]
}

type User {
    id: ID
    name: String
    email: @requiresScopes(["user:read"])
}

type Product {
    id: ID
    name: String
    amount: Int @requiresScopes(["employee", "inventory"])
    orders: [User] @requiresScopes(["employee"])
}
```

And this query:

```graphql
{
    me {
        name
        email
    }

    products {
        name
        amount
        orders {
            name
        }
    }
}
```

If the request presented the scopes `profile:read user:read`, then it would be interpreted as:


```graphql
{
    me {
        name
        email
    }

    products {
        name
    }
}
```

And generate an error at path `/products/@/amount`.

While if it presented the scopes `employee inventory`, it would filter the query as:

```graphql
{
    products {
        name
        amount
        orders {
            name
        }
    }
}
```

And generate an error at path `/me`.

## Composition and federation

The authorization directives are defined by the subgraph author, and will be carried into the supergraph schema:
- `@authenticated`: if defined on a field or type by any of the subgraphs, it will be set in the supergraph too
- `@requiresScopes`: same as `@authenticated`, and if there are multiple applications, the supergraph schema will merge the sets of scopes required by each subgraph

### Authorization and `@key`

When the authorization directives are set on fields used in `@key`, they will be usable by the router to join between subgraphs, but cannot be queried directly by the client. This behavior is similar to [contracts](/graphos/delivery/contracts/) and the [`@inaccessible` directive](https://www.apollographql.com/docs/federation/federated-types/federated-directives/#inaccessible).

As an example, assuming we have these subgraphs definition:

```graphql
# subgraph A
type Query {
  t: T
}

type T @key(fields: "id") {
  id: ID! @authenticated
}
```

```graphql
# subgraph B
type T @key(fields: "id") {
  id: ID! @authenticated
  value: Int
}
```

The following query can be done when not authenticated:

```graphql
{
  t {
    value
  }
}
```

But this one would end up with a `null` in `id`, which would trigger nullability rules and nullify `t` too.

```graphql
{
  t {
    id
    value
  }
}
```

### Interfaces

In the case one of the types implementing an interface requires authorization, then querying the interface will be allowed, but any parts that require access to that type will be filtered.

As an example, with this schema, where the interface  `I` does not require authentication, but the `User` type does:

```graphql
type Query {
  itf: I!
}

interface I {
    id: ID
}

type User
implements I
@authenticated {
  id: ID
  name: String
}
```

If we send this query with an inline fragment and a type condition on `User`:

```graphql
query {
    itf {
        id
        ... on User {
          name
        }
    }
}
```

The query would be filtered as follows:

```graphql
query {
  itf {
    id
  }
}
```

## Query deduplication

When [query deduplication](/configuration/traffic-shaping/#query-deduplication) is activated for subgraphs, the authorization status is accounted for: unauthenticated queries will be grouped together, and authenticated queries will be grouped by scope set.

## Introspection

Introspection is not affected by authorization, so all types fields will be accessible. The directives applied to them will not be visible though. If introspection might reveal too much information about internal types, then it should be deactivated like this:

```yaml
supergraph:
  introspection: false
```

Fields can also be hidden using [contracts](/graphos/delivery/contracts/).