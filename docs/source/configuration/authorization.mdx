---
title: Authorization in the Apollo Router
---

> ⚠️ **This is an [Enterprise feature](../enterprise-features/) of the Apollo Router.** It requires an organization with a [GraphOS Enterprise plan](https://www.apollographql.com/pricing/).
>
> If your organization _doesn't_ currently have an Enterprise plan, you can test out this functionality by signing up for a free [Enterprise trial](/graphos/org/plans/#enterprise-trials).

The Apollo Router supports graph based authorization policies, through the `@authenticated` and `@requiresScopes` directives. They are used to authorize access to specific types or fields.

They are defined as follows:

```graphql
directive @authenticated on OBJECT | FIELD_DEFINITION | INTERFACE | SCALAR | ENUM

directive @requiresScopes(scopes: [String!]!) on OBJECT | FIELD_DEFINITION | INTERFACE | SCALAR | ENUM
```

To use them, you need either to configure [JWT authentication](./authn-jwt) or to add a [router service coprocessor](../customizations/coprocessor). The JWT plugin will validate the token, extract its claims and set them in the request context at the key `apollo_authentication::JWT::claims`. To participate in the authorization process, a coprocessor would need to set that key in the context.

## `@authenticated`

The `@authenticated` directive restricts access to fields and types if the request was not authenticated, by checking for the presence of the `apollo_authentication::JWT::claims` key in the request context. If those fields are restricted, the router will remove them entirely before planning the query, so the unauthenticated parts will still be executed and returned to the client, but the parts requiring authentication will never be requested from subgraphs, avoiding entire subgraph requests in some cases.

As an example, assuming we have this schema:

```graphql
type Query {
    me: User @authenticated
    user(id: ID): User
}

type User {
    id: ID
    name: String
    email: @authenticated
}
```

And this query:

```graphql
{
    me {
        name
        email
    }

    user(id: 1234) {
        name
        email
    }
}
```

If the request was authenticated, the entire query would be executed, as expected. But if it wasn't, the router would remove fields before execution, and create this filtered query:

```graphql
{
    user(id: 1234) {
        name
    }
}
```

So the `me` top level operation would not even be executed. When returning the response, the router will follow the initial request's shape and insert a null in the unauthorized fields, and apply the null propagation rules. It will generate a response of the following shape:

```json
{
  "data": {
    "me": null,
    "user": {
        "name": "Ada",
        "email": null
    }
  },
  "errors": [
    {
      "message": "Unauthorized field or type",
      "path": [
        "me"
      ],
      "extensions": {
        "code": "UNAUTHORIZED_FIELD_OR_TYPE"
      }
    },
    {
      "message": "Unauthorized field or type",
      "path": [
        "user",
        "email"
      ],
      "extensions": {
        "code": "UNAUTHORIZED_FIELD_OR_TYPE"
      }
    }
  ]
}
```

If all the fields were removed, then the router would generate a query planner error indicating that the query is unauthorized.

## `@requiresScopes`

The `@requiresScopes` directive restricts access to fields and types if the request did not present the right set of scopes, by loading from the request the context the object at key `apollo_authentication::JWT::claims`, and in that object the `scope` key, in the format defined by [OAuth2 access token scopes](https://datatracker.ietf.org/doc/html/rfc6749#section-3.3), as a space separated list of scopes.

Depending on which scope set is presented by the request, different parts of the query may be available.

Assuming we have this schema:

```graphql
type Query {
    me: User @requiresScopes(scopes: ["profile:read"])
    products: [Products]
}

type User {
    id: ID
    name: String
    email: @requiresScopes(["user:read"])
}

type Product {
    id: ID
    name: String
    amount: Int @requiresScopes(["employee", "inventory"])
    orders: [User] @requiresScopes(["employee"])
}
```

And this query:

```graphql
{
    me {
        name
        email
    }

    products {
        name
        amount
        orders {
            name
        }
    }
}
```

If the request presented the scopes `profile:read user:read`, then it would be interpreted as:


```graphql
{
    me {
        name
        email
    }

    products {
        name
    }
}
```

And generate an error at path `/products/@/amount`.

While if it presented the scopes `employee inventory`, it would filter the query as:

```graphql
{
    products {
        name
        amount
        orders {
            name
        }
    }
}
```

And generate an error at path `/me`.


## Composition and federation

The authorization directives are defined by the subgraph author, and will be carried into the supergraph schema:
- `@authenticated`: if defined on a field or type by any of the subgraphs, it will be set in the supergraph too
- `@requiresScopes`: same as `@authenticated`, and if there are multiple applications, the supergraph schema will merge the sets of scopes required by each subgraph

### Authorization and `@key`

When the authorization directives are set on fields used in `@key`, they will be usable by the router to join between subgraphs, but cannot be queried directly by the client. This behavior is similar to [Contracts](/graphos/delivery/contracts/) and the [`@inaccessible` directive](https://www.apollographql.com/docs/federation/federated-types/federated-directives/#inaccessible).

As an example, assuming we have these subgraphs definition:

```graphql
# subgraph A
type Query {
  t: T
}

type T @key(fields: "id") {
  id: ID! @authenticated
}
```

```graphql
# subgraph B
type T @key(fields: "id") {
  id: ID! @authenticated
  value: Int
}
```

The following query can be done when not authenticated:

```graphql
{
  t {
    value
  }
}
```

But this one would end up with a `null` in `id`, which would trigger nullability rules and nullify `t` too.

```graphql
{
  t {
    id
    value
  }
}
```

### Interfaces

In the case one of the types implementing an interface requires authorization, then querying the interface will be allowed, but any parts that require access to that type will be filtered.

As an example, with this schema, where the interface  `I` does not require authentication, but the `User` type does:

```graphql
type Query {
  itf: I!
}

interface I {
    id: ID
}

type User
implements I
@authenticated {
  id: ID
  name: String
}
```

If we send this query with a fragment and a type condition on `User`:

```graphql
query {
    topProducts {
        type
    }
    itf {
        id
        ...F
    }
}

fragment F on User {
    name
}
```

The query would be filtered as follows:

```graphql
query {
  topProducts {
    type
  }
  itf {
    id
  }
}
```

### Introspection

Introspection is not affected by authorization, so all types fields will be accessible. The directives applied to them will not be visible though. If introspection might reveal too much information about internal types, then it should be deactivated like this:

```yaml
supergraph:
  introspection: false
```

### Query deduplication

When [query deduplication](/configuration/traffic-shaping/#query-deduplication) is activated for subgraphs, the authorization status is accounted for: unauthenticated queries will be grouped together, and authenticated queries will be grouped by scope set.